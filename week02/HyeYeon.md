## 11. 잉여 속성 체크의 한계 인지하기

### 잉여 속성 체크

- 타입에 선언된 속성 외의 속성은 없는지 체크
- 할당 가능 검사와는 별도의 과정
- 엄격한 객체 리터럴 체크(객체 리터럴에 알 수 없는 속성을 허용하지 않음)
- 객체 리터럴이 아닌 경우 적용되지 않음

## 12. 함수 표현식에 타입 적용하기

- 함수 표현식을 사용하면 함수 타입을 재사용할 수 있고, 함수 구현부를 분리할 수 있다는 장점

## 13. 타입과 인터페이스의 차이점 알기

- 인터페이스는 유니온 타입과 같이 복잡한 타입을 확장하지 못함
- 인터페이스는 선언 병합이 가능하므로 타입 선언 파일을 작성할 때는 인터페이스를 사용
- 타입은 기존 타입에 추가적인 보강이 없는 경우에 사용
- 같은 상황에서는 동일한 방법으로 명명된 타입을 정의하여 일관성을 유지

## 14. 타입 연산과 제너릭 사용으로 반복 줄이기

- 타입에 이름을 붙여 반복 줄이기

  ```ts
  const distance = (a: { x: number; y: number }, b: { x: number; y: number }) =>
    Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
  ```

  ⬇

  ```ts
  interface Point {
    x: number;
    y: number;
  }
  const distance = (a: Point, b: Point) =>
    Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
  ```

- 인터페이스를 확장하여 반복을 제거하기
- 매핑된 타입 사용하기
- 제너릭 타입 사용하기

## 15. 동적 데이터에 인덱스 시그니처 사용하기

- 타입에 인덱스 시그니처를 명시하여 유연하게 매핑을 표현
- 연관배열의 경우 인덱스 시그니처 대신 Map 타입을 사용
- string 태입으로 인덱스 시그니처를 사용하는 데 문제가 있을 때의 대안
  - Record(키 타입에 유연성을 제공하는 제너릭 타입) 사용
  - 매핑된 타입을 사용하여 키마다 별도의 타입 사용

## 16. number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

- 자바스크립트에서 배열의 인덱스가 문자열로 변환되는 점을 해결하기 위해 타입스크립트는 수자 키를 허용
- Object.keys에서는 숫자 키가 문자열로 반환되지만 배열을 순회할 때는 string이 number에 할당되는 것을 허용
  - 인덱스의 타입이 중요한 경우에는 forEach나 for문을 사용하여 순회

## 17. 변경 관련된 오류 방지를 위해 readonly 사용하기

- 매개변수를 변경하지 않기 위해 readonly 접근 제어자 사용
- 변경 가능한 배열을 readonly 배열에 할당할 수는 있으나 readonly에 변경 가능한 배열을 할당할 수는 없음
- 다른 라이브러리의 함수를 호출할 때는 타입 선언을 바꿀 수 없으므로 타입 단언문(`as number[]`)를 사용
- readonly는 얕게 동작하지만, 제너릭을 만들거나 라이브러리를 사용하면 깊은 readonly 타입을 사용 가능

## 18. 매핑된 타입을 사용하여 값을 동기화하기

- 새로운 속성이 추가될 때 shouldUpdate를 고쳐 최적화할 수 있으나, 타입 체커가 대신할 수 있게 하는 것이 좋음
  - 매핑된 타입과 객체를 사용
- 매핑된 타입은 한 객체가 또 다른 객체와 정확히 같은 속성을 가지게 할 때 이상적

## 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

- 코드의 모든 변수에 타입을 선언하는 것은 비생산적
  - 타입 추론이 된다면 명시적으로 타입을 선언하는 것이 불필요
- 타입을 확신하지 못한다면 편집기를 통해 체크
- 정보가 부족해서 타입스크립트가 스스로 타입을 판단하기 어려운 상황에서는 명시적인 타입 선언 필요
- 함수 내에서 생성된 지역 변수에는 타입 구문을 생략하는 것이 좋음
- 객체 리터럴을 정의할 때에는 타입이 추론될 수 있어도 타입을 명시할 경우 잉여 속성 체크가 동작함
- 의도된 반환 타입을 명시하면 정확한 위치에 오류가 표시되고, 함수에 대해 더욱 명확하게 알 수 있으며 명명된 타입을 사용할 수 있음
- eslint `no-inferrable-types`를 사용

## 20. 다른 타입에는 다른 변수 사용하기

- 타입스크립트는 자바스크립트와 달리 변수를 다른 타입으로 재할당할 수 없음
- 유니온 타입을 사용하여 다른 타입 할당 가능하나, 변수를 사용할 때마다 타입을 확인해야 하므로 다루기가 더 어려움
- 다른 타입에는 별도의 변수를 사용할 때의 이점
  - 서로 관련이 없는 값을 분리
  - 변수명 구체화
  - 타입 추론을 향상, 타입 구문 생략 가능, 간결한 타입 사용
  - let 대신 const를 사용하여 코드를 간결하게 사용
