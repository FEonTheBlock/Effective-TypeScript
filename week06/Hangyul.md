# 2022년 3월 23일 한결 공부내용


## 아이템 36: 해당 분야의 용어로 타입 이름 짓기
    
- 모든 분야에는 주제를 설명하기 위한 전문 용어들이 있으니, 해당 분야에 이미 존재하는 용어를 사용하여 사용자와 소통에 유리하게 하고 타입의 명확성을 높이자.
- 모호하고 의미 없는 이름(data, info, thing, item 등)을 피한다
    
## 아이템 37: 공식 명칭에는 상표를 붙이기
    
- 구조적 타이핑 때문에 다른 형태의 타입을 허용하는 경우를 방지하기 위해, 상표(brand)를 붙일 수 있다.
- 상표는 `_brand`와 같은 별도의 타입 필드를 정의해서 해당 타입만 받는 것을 보장한다. 일부러 상표를 작성하여 타입 체커를 통과하는 것까지 막을 순 없지만 단순한 실수를 방지하기에는 충분하다.
    
## 아이템 38: any 타입은 가능한 한 좁은 범위에서만 사용하기
- `Bar` 타입만 받는 `processBar` 함수에 `Foo` 타입을 갖는 변수(그러나 `Bar` 타입에도 할당 가능)를 전달해야 할 때
        
    ```tsx
    function f1() {
        const x: any = expressionReturningFoo();
        processBar(x);
        return x;
    };
    ```
    
    - 이렇게 하면 x는 f1 함수가 끝날 때까지 x 타입이 any이며, return이라도 하는 경우엔 x가 any 타입을 가지고 return 되어 이후에 타입체크가 제대로 이뤄지지 않는다.
    
    ```tsx
    function f2() {
        const x = expressionReturningFoo();
        processBar(x as any);
        return x;
    }
    ```
    
    - f2 함수와 같이 `as any` 형태로 x의 타입을 변경하는 것이 더 바람직한데, 이는 x의 any 타입을 좁게 사용하여 `processBar` 함수의 매개변수에서만 사용되며 다른 코드에 영향을 미치지 않기 때문이다.
- 또한 함수의 반환 타입을 명시하여 `any` 타입이 함수 바깥으로 영향을 미치는 것을 방지하고, 객체 안에서 객체 전체가 아닌, 최소한의 범위에서 필요한 속성에 대해서만 `as any`를 단언한다.

## 아이템 39: any를 구체적으로 변형해서 사용하기
    
- any는 JS의 모든 값을 아우르는 매우 큰 범위의 타입이므로 더 구체적으로 표현할 수 있는 타입을 찾아 정의한다.     
- 요소를 알 수 없지만 array인 경우: `any[]`
- 배열의 배열형태인 경우: `any[][]`
- 값을 알 수 없지만 객체인 경우: `{[key:string]: any}`
    - 모든 비원시값 타입을 포함하는 `object` 타입을 사용할 수도 있다. 
    (객체의 키를 열거할 수 있지만 속성에 접근할 수는 없음)
    - 객체지만 속성에 접근할 수 없어야 한다면 unknown 타입 (⇒ 아이템 42)
- 함수인 경우: `() => any`, `(arg: any) => any`, `(...args: any[]) => any`

## 아이템 40: 함수 안으로 타입 단언문 감추기
    
- 함수 내부에 타입단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도로 끝내는 것이 예외상황까지 고려하며 힘들게 타입정보를 구성하는 것보다 낫다.
- 객체가 같은지 체크하기 위해 객체 순회와 단언문이 코드에 직접 들어가는 것보다, 별도의 함수로 분리해내는 것이 훨씬 좋다.